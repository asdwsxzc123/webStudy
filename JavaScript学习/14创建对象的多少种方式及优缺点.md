### 1.工厂函数
```js
function createPerson(name) {
  var o = new Object();
  o.name = name;
  o.getName = function () {
    console.log(this.name)
  }
  return o
}
```
缺点: 对象无法识别,因为所有的实例指向一个原型
### 2.构造函数模式
```js
function Person(name) {
  this.name = name;
  this.getName = function () {
    console.log(this.name)
  }
}
```
优点: 实例可以识别为一个特定的类型
缺点: 每次创建实例时,每个方法都要被创建一次
### 2.1构造函数模式优化
```js
function Person(name) {
    this.name = name;
    this.getName = getName;
}

function getName() {
    console.log(this.name);
}
```
优点: 解决了每个方法都要被重新创建的问题
缺点: 没有封装
### 3.原型模式
```js
function Person(name) {

}
Person.prototype = {
  name: 'kevin',
  getName: function () {
    console.log(this.name)
  }
}
```
优点: 方法不会重新创建
缺点: 1. 所有的属性和方法都共享 2.不能初始化参数
优点: 封装性好一点
缺点: 重写了原型,丢失了constructor属性
