## Stack 栈

先进后出
Array or Linked list

## Queue 队列

先进先出

## 例子

```js
// 20题
// 左右括号的合法性 [({})]
function isValid(s) {
  var stack = [];
  var parenMap = {
    ')': '(',
    ']': '[',
    '}': '{'
  };
  for (var i = 0; i < s.length; i++) {
    var c = s[i];
    if (!parenMap[c]) {
      stack.push(c);
    } else if (parenMap[c] !== stack.pop()) {
      return false;
    }
  }
  return true;
}
```

## 优先队列 priorityQueue

正常入,按照优先级出,数字越小级别越高

实现机制

1. heap (binary, binomial,fibonacci) // 堆
2. binary search tree

### 优先队列 js 实现

### mini Heap

小顶堆,父节点小于子节点

快速排序 k log k

### 习题

#### 1. 前 k 个元素的最大值

```
k=3, [4,5,8,2]
```

1, k,max => sort n*k*logK

2. mini Heap
   size = k

#### 239. 滑动窗口最大值

给定一个数组 nums，有一个大小为  k  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k  个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]

1. 大顶堆,最大的值在最上面

2. 双端队列,队列第一个值最大,小的放后面

```js
var maxSlidingWindow = function(nums, k) {
  // 先判断数据的合法性
  if (!nums) return [];
  // 1. 需要一个数组push最大值,还需要一个数组push k个元素
  let arr = [];
  let maxList = [];
  nums.forEach((num, i) => {
    // 实现push和shift操作,num[0]永远是最大值
    // shift操作,当下标>=k,并且第0项索引<=i-k的时候才需要将第一个弹出,
    if (i >= k && arr[0] <= i - k) {
      arr.shift();
    }
    // 新的数据插入会删除之前小的数据
    for (let j = arr.length - 1; j >= 0; j--) {
      const element = nums[arr[j]];
      if (element <= num) {
        arr.pop();
      }
    }
    // 每次遍历都会push一次
    arr.push(i);
    // 只有i >= k - 1(单一职责,这里值做插入到maxList的操作)
    if (i >= k - 1) {
      maxList.push(nums[arr[0]]);
    }
  });
  return maxList;
};
var nums = [1, 3, 1, 2, 0, 5],
  k = 3;
console.log(maxSlidingWindow(nums, k));
```
